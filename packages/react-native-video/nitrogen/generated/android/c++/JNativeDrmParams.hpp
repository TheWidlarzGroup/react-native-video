///
/// JNativeDrmParams.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "NativeDrmParams.hpp"

#include "JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload.hpp"
#include "JOnGetLicensePayload.hpp"
#include "OnGetLicensePayload.hpp"
#include <NitroModules/JPromise.hpp>
#include <NitroModules/Promise.hpp>
#include <functional>
#include <optional>
#include <string>
#include <unordered_map>

namespace margelo::nitro::video {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "NativeDrmParams" and the the Kotlin data class "NativeDrmParams".
   */
  struct JNativeDrmParams final: public jni::JavaClass<JNativeDrmParams> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/video/NativeDrmParams;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct NativeDrmParams by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    NativeDrmParams toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldType = clazz->getField<jni::JString>("type");
      jni::local_ref<jni::JString> type = this->getFieldValue(fieldType);
      static const auto fieldLicenseUrl = clazz->getField<jni::JString>("licenseUrl");
      jni::local_ref<jni::JString> licenseUrl = this->getFieldValue(fieldLicenseUrl);
      static const auto fieldCertificateUrl = clazz->getField<jni::JString>("certificateUrl");
      jni::local_ref<jni::JString> certificateUrl = this->getFieldValue(fieldCertificateUrl);
      static const auto fieldContentId = clazz->getField<jni::JString>("contentId");
      jni::local_ref<jni::JString> contentId = this->getFieldValue(fieldContentId);
      static const auto fieldLicenseHeaders = clazz->getField<jni::JMap<jni::JString, jni::JString>>("licenseHeaders");
      jni::local_ref<jni::JMap<jni::JString, jni::JString>> licenseHeaders = this->getFieldValue(fieldLicenseHeaders);
      static const auto fieldMultiSession = clazz->getField<jni::JBoolean>("multiSession");
      jni::local_ref<jni::JBoolean> multiSession = this->getFieldValue(fieldMultiSession);
      static const auto fieldGetLicense = clazz->getField<JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload::javaobject>("getLicense");
      jni::local_ref<JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload::javaobject> getLicense = this->getFieldValue(fieldGetLicense);
      return NativeDrmParams(
        type != nullptr ? std::make_optional(type->toStdString()) : std::nullopt,
        licenseUrl != nullptr ? std::make_optional(licenseUrl->toStdString()) : std::nullopt,
        certificateUrl != nullptr ? std::make_optional(certificateUrl->toStdString()) : std::nullopt,
        contentId != nullptr ? std::make_optional(contentId->toStdString()) : std::nullopt,
        licenseHeaders != nullptr ? std::make_optional([&]() {
          std::unordered_map<std::string, std::string> __map;
          __map.reserve(licenseHeaders->size());
          for (const auto& __entry : *licenseHeaders) {
            __map.emplace(__entry.first->toStdString(), __entry.second->toStdString());
          }
          return __map;
        }()) : std::nullopt,
        multiSession != nullptr ? std::make_optional(static_cast<bool>(multiSession->value())) : std::nullopt,
        getLicense != nullptr ? std::make_optional([&]() -> std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)> {
          if (getLicense->isInstanceOf(JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload_cxx::javaClassStatic())) [[likely]] {
            auto downcast = jni::static_ref_cast<JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload_cxx::javaobject>(getLicense);
            return downcast->cthis()->getFunction();
          } else {
            auto getLicenseRef = jni::make_global(getLicense);
            return [getLicenseRef](OnGetLicensePayload payload) -> std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>> {
              return getLicenseRef->invoke(payload);
            };
          }
        }()) : std::nullopt
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JNativeDrmParams::javaobject> fromCpp(const NativeDrmParams& value) {
      return newInstance(
        value.type.has_value() ? jni::make_jstring(value.type.value()) : nullptr,
        value.licenseUrl.has_value() ? jni::make_jstring(value.licenseUrl.value()) : nullptr,
        value.certificateUrl.has_value() ? jni::make_jstring(value.certificateUrl.value()) : nullptr,
        value.contentId.has_value() ? jni::make_jstring(value.contentId.value()) : nullptr,
        value.licenseHeaders.has_value() ? [&]() -> jni::local_ref<jni::JMap<jni::JString, jni::JString>> {
          auto __map = jni::JHashMap<jni::JString, jni::JString>::create(value.licenseHeaders.value().size());
          for (const auto& __entry : value.licenseHeaders.value()) {
            __map->put(jni::make_jstring(__entry.first), jni::make_jstring(__entry.second));
          }
          return __map;
        }() : nullptr,
        value.multiSession.has_value() ? jni::JBoolean::valueOf(value.multiSession.value()) : nullptr,
        value.getLicense.has_value() ? JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload_cxx::fromCpp(value.getLicense.value()) : nullptr
      );
    }
  };

} // namespace margelo::nitro::video
