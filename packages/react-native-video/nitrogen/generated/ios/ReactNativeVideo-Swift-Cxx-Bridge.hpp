///
/// ReactNativeVideo-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `BandwidthData` to properly resolve imports.
namespace margelo::nitro::video { struct BandwidthData; }
// Forward declaration of `BufferConfig` to properly resolve imports.
namespace margelo::nitro::video { struct BufferConfig; }
// Forward declaration of `CustomVideoMetadata` to properly resolve imports.
namespace margelo::nitro::video { struct CustomVideoMetadata; }
// Forward declaration of `HybridVideoPlayerEventEmitterSpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerEventEmitterSpec; }
// Forward declaration of `HybridVideoPlayerFactorySpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerFactorySpec; }
// Forward declaration of `HybridVideoPlayerSourceFactorySpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerSourceFactorySpec; }
// Forward declaration of `HybridVideoPlayerSourceSpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerSourceSpec; }
// Forward declaration of `HybridVideoPlayerSpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerSpec; }
// Forward declaration of `HybridVideoViewViewManagerFactorySpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoViewViewManagerFactorySpec; }
// Forward declaration of `HybridVideoViewViewManagerSpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoViewViewManagerSpec; }
// Forward declaration of `ListenerSubscription` to properly resolve imports.
namespace margelo::nitro::video { struct ListenerSubscription; }
// Forward declaration of `LivePlaybackParams` to properly resolve imports.
namespace margelo::nitro::video { struct LivePlaybackParams; }
// Forward declaration of `NativeDrmParams` to properly resolve imports.
namespace margelo::nitro::video { struct NativeDrmParams; }
// Forward declaration of `NativeExternalSubtitle` to properly resolve imports.
namespace margelo::nitro::video { struct NativeExternalSubtitle; }
// Forward declaration of `OnGetLicensePayload` to properly resolve imports.
namespace margelo::nitro::video { struct OnGetLicensePayload; }
// Forward declaration of `Resolution` to properly resolve imports.
namespace margelo::nitro::video { struct Resolution; }
// Forward declaration of `SourceType` to properly resolve imports.
namespace margelo::nitro::video { enum class SourceType; }
// Forward declaration of `SubtitleType` to properly resolve imports.
namespace margelo::nitro::video { enum class SubtitleType; }
// Forward declaration of `TextTrack` to properly resolve imports.
namespace margelo::nitro::video { struct TextTrack; }
// Forward declaration of `TimedMetadataObject` to properly resolve imports.
namespace margelo::nitro::video { struct TimedMetadataObject; }
// Forward declaration of `TimedMetadata` to properly resolve imports.
namespace margelo::nitro::video { struct TimedMetadata; }
// Forward declaration of `VideoInformation` to properly resolve imports.
namespace margelo::nitro::video { struct VideoInformation; }
// Forward declaration of `VideoOrientation` to properly resolve imports.
namespace margelo::nitro::video { enum class VideoOrientation; }
// Forward declaration of `VideoPlayerStatus` to properly resolve imports.
namespace margelo::nitro::video { enum class VideoPlayerStatus; }
// Forward declaration of `onLoadData` to properly resolve imports.
namespace margelo::nitro::video { struct onLoadData; }
// Forward declaration of `onLoadStartData` to properly resolve imports.
namespace margelo::nitro::video { struct onLoadStartData; }
// Forward declaration of `onPlaybackStateChangeData` to properly resolve imports.
namespace margelo::nitro::video { struct onPlaybackStateChangeData; }
// Forward declaration of `onProgressData` to properly resolve imports.
namespace margelo::nitro::video { struct onProgressData; }
// Forward declaration of `onVolumeChangeData` to properly resolve imports.
namespace margelo::nitro::video { struct onVolumeChangeData; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridVideoPlayerEventEmitterSpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerEventEmitterSpec_cxx; }
// Forward declaration of `HybridVideoPlayerFactorySpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerFactorySpec_cxx; }
// Forward declaration of `HybridVideoPlayerSourceFactorySpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerSourceFactorySpec_cxx; }
// Forward declaration of `HybridVideoPlayerSourceSpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerSourceSpec_cxx; }
// Forward declaration of `HybridVideoPlayerSpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerSpec_cxx; }
// Forward declaration of `HybridVideoViewViewManagerFactorySpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoViewViewManagerFactorySpec_cxx; }
// Forward declaration of `HybridVideoViewViewManagerSpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoViewViewManagerSpec_cxx; }

// Include C++ defined types
#include "BandwidthData.hpp"
#include "BufferConfig.hpp"
#include "CustomVideoMetadata.hpp"
#include "HybridVideoPlayerEventEmitterSpec.hpp"
#include "HybridVideoPlayerFactorySpec.hpp"
#include "HybridVideoPlayerSourceFactorySpec.hpp"
#include "HybridVideoPlayerSourceSpec.hpp"
#include "HybridVideoPlayerSpec.hpp"
#include "HybridVideoViewViewManagerFactorySpec.hpp"
#include "HybridVideoViewViewManagerSpec.hpp"
#include "ListenerSubscription.hpp"
#include "LivePlaybackParams.hpp"
#include "NativeDrmParams.hpp"
#include "NativeExternalSubtitle.hpp"
#include "OnGetLicensePayload.hpp"
#include "Resolution.hpp"
#include "SourceType.hpp"
#include "SubtitleType.hpp"
#include "TextTrack.hpp"
#include "TimedMetadata.hpp"
#include "TimedMetadataObject.hpp"
#include "VideoInformation.hpp"
#include "VideoOrientation.hpp"
#include "VideoPlayerStatus.hpp"
#include "onLoadData.hpp"
#include "onLoadStartData.hpp"
#include "onPlaybackStateChangeData.hpp"
#include "onProgressData.hpp"
#include "onVolumeChangeData.hpp"
#include <NitroModules/Null.hpp>
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <variant>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::video::bridge::swift {

  // pragma MARK: std::shared_ptr<HybridVideoPlayerSourceSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridVideoPlayerSourceSpec>`.
   */
  using std__shared_ptr_HybridVideoPlayerSourceSpec_ = std::shared_ptr<HybridVideoPlayerSourceSpec>;
  std::shared_ptr<HybridVideoPlayerSourceSpec> create_std__shared_ptr_HybridVideoPlayerSourceSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridVideoPlayerSourceSpec_(std__shared_ptr_HybridVideoPlayerSourceSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridVideoPlayerSourceSpec>
  using std__weak_ptr_HybridVideoPlayerSourceSpec_ = std::weak_ptr<HybridVideoPlayerSourceSpec>;
  inline std__weak_ptr_HybridVideoPlayerSourceSpec_ weakify_std__shared_ptr_HybridVideoPlayerSourceSpec_(const std::shared_ptr<HybridVideoPlayerSourceSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<HybridVideoPlayerEventEmitterSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridVideoPlayerEventEmitterSpec>`.
   */
  using std__shared_ptr_HybridVideoPlayerEventEmitterSpec_ = std::shared_ptr<HybridVideoPlayerEventEmitterSpec>;
  std::shared_ptr<HybridVideoPlayerEventEmitterSpec> create_std__shared_ptr_HybridVideoPlayerEventEmitterSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridVideoPlayerEventEmitterSpec_(std__shared_ptr_HybridVideoPlayerEventEmitterSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridVideoPlayerEventEmitterSpec>
  using std__weak_ptr_HybridVideoPlayerEventEmitterSpec_ = std::weak_ptr<HybridVideoPlayerEventEmitterSpec>;
  inline std__weak_ptr_HybridVideoPlayerEventEmitterSpec_ weakify_std__shared_ptr_HybridVideoPlayerEventEmitterSpec_(const std::shared_ptr<HybridVideoPlayerEventEmitterSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<Promise<void>>
  /**
   * Specialized version of `std::shared_ptr<Promise<void>>`.
   */
  using std__shared_ptr_Promise_void__ = std::shared_ptr<Promise<void>>;
  inline std::shared_ptr<Promise<void>> create_std__shared_ptr_Promise_void__() noexcept {
    return Promise<void>::create();
  }
  inline PromiseHolder<void> wrap_std__shared_ptr_Promise_void__(std::shared_ptr<Promise<void>> promise) noexcept {
    return PromiseHolder<void>(std::move(promise));
  }
  
  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_unique<std::function<void()>>(std::move(func))) {}
    inline void call() const noexcept {
      _function->operator()();
    }
  private:
    std::unique_ptr<std::function<void()>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Wrapper wrap_Func_void(Func_void value) noexcept {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_unique<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) noexcept {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec__ {
    std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>> variant;
    std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec__(std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>> variant): variant(variant) { }
    operator std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline std::shared_ptr<HybridVideoPlayerSourceSpec> get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec__ create_std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec__(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec__(value);
  }
  inline std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec__ create_std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec__(const std::shared_ptr<HybridVideoPlayerSourceSpec>& value) noexcept {
    return std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec__(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>>`.
   */
  using std__optional_std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec___ = std::optional<std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>>;
  inline std::optional<std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>> create_std__optional_std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec___(const std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec___(const std::optional<std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>> get_std__optional_std__variant_nitro__NullType__std__shared_ptr_HybridVideoPlayerSourceSpec___(const std::optional<std::variant<nitro::NullType, std::shared_ptr<HybridVideoPlayerSourceSpec>>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<TextTrack>
  /**
   * Specialized version of `std::vector<TextTrack>`.
   */
  using std__vector_TextTrack_ = std::vector<TextTrack>;
  inline std::vector<TextTrack> create_std__vector_TextTrack_(size_t size) noexcept {
    std::vector<TextTrack> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<nitro::NullType, TextTrack>
  /**
   * Wrapper struct for `std::variant<nitro::NullType, TextTrack>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_nitro__NullType__TextTrack_ {
    std::variant<nitro::NullType, TextTrack> variant;
    std__variant_nitro__NullType__TextTrack_(std::variant<nitro::NullType, TextTrack> variant): variant(variant) { }
    operator std::variant<nitro::NullType, TextTrack>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline nitro::NullType get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline TextTrack get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_nitro__NullType__TextTrack_ create_std__variant_nitro__NullType__TextTrack_(nitro::NullType value) noexcept {
    return std__variant_nitro__NullType__TextTrack_(value);
  }
  inline std__variant_nitro__NullType__TextTrack_ create_std__variant_nitro__NullType__TextTrack_(const TextTrack& value) noexcept {
    return std__variant_nitro__NullType__TextTrack_(value);
  }
  
  // pragma MARK: std::optional<std::variant<nitro::NullType, TextTrack>>
  /**
   * Specialized version of `std::optional<std::variant<nitro::NullType, TextTrack>>`.
   */
  using std__optional_std__variant_nitro__NullType__TextTrack__ = std::optional<std::variant<nitro::NullType, TextTrack>>;
  inline std::optional<std::variant<nitro::NullType, TextTrack>> create_std__optional_std__variant_nitro__NullType__TextTrack__(const std::variant<nitro::NullType, TextTrack>& value) noexcept {
    return std::optional<std::variant<nitro::NullType, TextTrack>>(value);
  }
  inline bool has_value_std__optional_std__variant_nitro__NullType__TextTrack__(const std::optional<std::variant<nitro::NullType, TextTrack>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<nitro::NullType, TextTrack> get_std__optional_std__variant_nitro__NullType__TextTrack__(const std::optional<std::variant<nitro::NullType, TextTrack>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<TextTrack>
  /**
   * Specialized version of `std::optional<TextTrack>`.
   */
  using std__optional_TextTrack_ = std::optional<TextTrack>;
  inline std::optional<TextTrack> create_std__optional_TextTrack_(const TextTrack& value) noexcept {
    return std::optional<TextTrack>(value);
  }
  inline bool has_value_std__optional_TextTrack_(const std::optional<TextTrack>& optional) noexcept {
    return optional.has_value();
  }
  inline TextTrack get_std__optional_TextTrack_(const std::optional<TextTrack>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridVideoPlayerSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridVideoPlayerSpec>`.
   */
  using std__shared_ptr_HybridVideoPlayerSpec_ = std::shared_ptr<HybridVideoPlayerSpec>;
  std::shared_ptr<HybridVideoPlayerSpec> create_std__shared_ptr_HybridVideoPlayerSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridVideoPlayerSpec_(std__shared_ptr_HybridVideoPlayerSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridVideoPlayerSpec>
  using std__weak_ptr_HybridVideoPlayerSpec_ = std::weak_ptr<HybridVideoPlayerSpec>;
  inline std__weak_ptr_HybridVideoPlayerSpec_ weakify_std__shared_ptr_HybridVideoPlayerSpec_(const std::shared_ptr<HybridVideoPlayerSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<void>>>
  using Result_std__shared_ptr_Promise_void___ = Result<std::shared_ptr<Promise<void>>>;
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::shared_ptr<Promise<void>>& value) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withError(error);
  }
  
  // pragma MARK: Result<std::vector<TextTrack>>
  using Result_std__vector_TextTrack__ = Result<std::vector<TextTrack>>;
  inline Result_std__vector_TextTrack__ create_Result_std__vector_TextTrack__(const std::vector<TextTrack>& value) noexcept {
    return Result<std::vector<TextTrack>>::withValue(value);
  }
  inline Result_std__vector_TextTrack__ create_Result_std__vector_TextTrack__(const std::exception_ptr& error) noexcept {
    return Result<std::vector<TextTrack>>::withError(error);
  }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<HybridVideoPlayerFactorySpec>
  /**
   * Specialized version of `std::shared_ptr<HybridVideoPlayerFactorySpec>`.
   */
  using std__shared_ptr_HybridVideoPlayerFactorySpec_ = std::shared_ptr<HybridVideoPlayerFactorySpec>;
  std::shared_ptr<HybridVideoPlayerFactorySpec> create_std__shared_ptr_HybridVideoPlayerFactorySpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridVideoPlayerFactorySpec_(std__shared_ptr_HybridVideoPlayerFactorySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridVideoPlayerFactorySpec>
  using std__weak_ptr_HybridVideoPlayerFactorySpec_ = std::weak_ptr<HybridVideoPlayerFactorySpec>;
  inline std__weak_ptr_HybridVideoPlayerFactorySpec_ weakify_std__shared_ptr_HybridVideoPlayerFactorySpec_(const std::shared_ptr<HybridVideoPlayerFactorySpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<HybridVideoPlayerSpec>>
  using Result_std__shared_ptr_HybridVideoPlayerSpec__ = Result<std::shared_ptr<HybridVideoPlayerSpec>>;
  inline Result_std__shared_ptr_HybridVideoPlayerSpec__ create_Result_std__shared_ptr_HybridVideoPlayerSpec__(const std::shared_ptr<HybridVideoPlayerSpec>& value) noexcept {
    return Result<std::shared_ptr<HybridVideoPlayerSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_HybridVideoPlayerSpec__ create_Result_std__shared_ptr_HybridVideoPlayerSpec__(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<HybridVideoPlayerSpec>>::withError(error);
  }
  
  // pragma MARK: std::function<void(bool /* hasAudioFocus */)>
  /**
   * Specialized version of `std::function<void(bool)>`.
   */
  using Func_void_bool = std::function<void(bool /* hasAudioFocus */)>;
  /**
   * Wrapper class for a `std::function<void(bool / * hasAudioFocus * /)>`, this can be used from Swift.
   */
  class Func_void_bool_Wrapper final {
  public:
    explicit Func_void_bool_Wrapper(std::function<void(bool /* hasAudioFocus */)>&& func): _function(std::make_unique<std::function<void(bool /* hasAudioFocus */)>>(std::move(func))) {}
    inline void call(bool hasAudioFocus) const noexcept {
      _function->operator()(hasAudioFocus);
    }
  private:
    std::unique_ptr<std::function<void(bool /* hasAudioFocus */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_bool create_Func_void_bool(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_bool_Wrapper wrap_Func_void_bool(Func_void_bool value) noexcept {
    return Func_void_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) noexcept {
    return std::optional<double>(value);
  }
  inline bool has_value_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.has_value();
  }
  inline double get_std__optional_double_(const std::optional<double>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const BandwidthData& /* data */)>
  /**
   * Specialized version of `std::function<void(const BandwidthData&)>`.
   */
  using Func_void_BandwidthData = std::function<void(const BandwidthData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const BandwidthData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_BandwidthData_Wrapper final {
  public:
    explicit Func_void_BandwidthData_Wrapper(std::function<void(const BandwidthData& /* data */)>&& func): _function(std::make_unique<std::function<void(const BandwidthData& /* data */)>>(std::move(func))) {}
    inline void call(BandwidthData data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const BandwidthData& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_BandwidthData create_Func_void_BandwidthData(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_BandwidthData_Wrapper wrap_Func_void_BandwidthData(Func_void_BandwidthData value) noexcept {
    return Func_void_BandwidthData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onLoadData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onLoadData&)>`.
   */
  using Func_void_onLoadData = std::function<void(const onLoadData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onLoadData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onLoadData_Wrapper final {
  public:
    explicit Func_void_onLoadData_Wrapper(std::function<void(const onLoadData& /* data */)>&& func): _function(std::make_unique<std::function<void(const onLoadData& /* data */)>>(std::move(func))) {}
    inline void call(onLoadData data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const onLoadData& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_onLoadData create_Func_void_onLoadData(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_onLoadData_Wrapper wrap_Func_void_onLoadData(Func_void_onLoadData value) noexcept {
    return Func_void_onLoadData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onLoadStartData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onLoadStartData&)>`.
   */
  using Func_void_onLoadStartData = std::function<void(const onLoadStartData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onLoadStartData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onLoadStartData_Wrapper final {
  public:
    explicit Func_void_onLoadStartData_Wrapper(std::function<void(const onLoadStartData& /* data */)>&& func): _function(std::make_unique<std::function<void(const onLoadStartData& /* data */)>>(std::move(func))) {}
    inline void call(onLoadStartData data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const onLoadStartData& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_onLoadStartData create_Func_void_onLoadStartData(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_onLoadStartData_Wrapper wrap_Func_void_onLoadStartData(Func_void_onLoadStartData value) noexcept {
    return Func_void_onLoadStartData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onPlaybackStateChangeData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onPlaybackStateChangeData&)>`.
   */
  using Func_void_onPlaybackStateChangeData = std::function<void(const onPlaybackStateChangeData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onPlaybackStateChangeData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onPlaybackStateChangeData_Wrapper final {
  public:
    explicit Func_void_onPlaybackStateChangeData_Wrapper(std::function<void(const onPlaybackStateChangeData& /* data */)>&& func): _function(std::make_unique<std::function<void(const onPlaybackStateChangeData& /* data */)>>(std::move(func))) {}
    inline void call(onPlaybackStateChangeData data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const onPlaybackStateChangeData& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_onPlaybackStateChangeData create_Func_void_onPlaybackStateChangeData(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_onPlaybackStateChangeData_Wrapper wrap_Func_void_onPlaybackStateChangeData(Func_void_onPlaybackStateChangeData value) noexcept {
    return Func_void_onPlaybackStateChangeData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(double /* rate */)>
  /**
   * Specialized version of `std::function<void(double)>`.
   */
  using Func_void_double = std::function<void(double /* rate */)>;
  /**
   * Wrapper class for a `std::function<void(double / * rate * /)>`, this can be used from Swift.
   */
  class Func_void_double_Wrapper final {
  public:
    explicit Func_void_double_Wrapper(std::function<void(double /* rate */)>&& func): _function(std::make_unique<std::function<void(double /* rate */)>>(std::move(func))) {}
    inline void call(double rate) const noexcept {
      _function->operator()(rate);
    }
  private:
    std::unique_ptr<std::function<void(double /* rate */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_double create_Func_void_double(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_double_Wrapper wrap_Func_void_double(Func_void_double value) noexcept {
    return Func_void_double_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onProgressData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onProgressData&)>`.
   */
  using Func_void_onProgressData = std::function<void(const onProgressData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onProgressData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onProgressData_Wrapper final {
  public:
    explicit Func_void_onProgressData_Wrapper(std::function<void(const onProgressData& /* data */)>&& func): _function(std::make_unique<std::function<void(const onProgressData& /* data */)>>(std::move(func))) {}
    inline void call(onProgressData data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const onProgressData& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_onProgressData create_Func_void_onProgressData(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_onProgressData_Wrapper wrap_Func_void_onProgressData(Func_void_onProgressData value) noexcept {
    return Func_void_onProgressData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(VideoPlayerStatus /* status */)>
  /**
   * Specialized version of `std::function<void(VideoPlayerStatus)>`.
   */
  using Func_void_VideoPlayerStatus = std::function<void(VideoPlayerStatus /* status */)>;
  /**
   * Wrapper class for a `std::function<void(VideoPlayerStatus / * status * /)>`, this can be used from Swift.
   */
  class Func_void_VideoPlayerStatus_Wrapper final {
  public:
    explicit Func_void_VideoPlayerStatus_Wrapper(std::function<void(VideoPlayerStatus /* status */)>&& func): _function(std::make_unique<std::function<void(VideoPlayerStatus /* status */)>>(std::move(func))) {}
    inline void call(int status) const noexcept {
      _function->operator()(static_cast<VideoPlayerStatus>(status));
    }
  private:
    std::unique_ptr<std::function<void(VideoPlayerStatus /* status */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_VideoPlayerStatus create_Func_void_VideoPlayerStatus(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_VideoPlayerStatus_Wrapper wrap_Func_void_VideoPlayerStatus(Func_void_VideoPlayerStatus value) noexcept {
    return Func_void_VideoPlayerStatus_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<TimedMetadataObject>
  /**
   * Specialized version of `std::vector<TimedMetadataObject>`.
   */
  using std__vector_TimedMetadataObject_ = std::vector<TimedMetadataObject>;
  inline std::vector<TimedMetadataObject> create_std__vector_TimedMetadataObject_(size_t size) noexcept {
    std::vector<TimedMetadataObject> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const TimedMetadata& /* data */)>
  /**
   * Specialized version of `std::function<void(const TimedMetadata&)>`.
   */
  using Func_void_TimedMetadata = std::function<void(const TimedMetadata& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const TimedMetadata& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_TimedMetadata_Wrapper final {
  public:
    explicit Func_void_TimedMetadata_Wrapper(std::function<void(const TimedMetadata& /* data */)>&& func): _function(std::make_unique<std::function<void(const TimedMetadata& /* data */)>>(std::move(func))) {}
    inline void call(TimedMetadata data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const TimedMetadata& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_TimedMetadata create_Func_void_TimedMetadata(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_TimedMetadata_Wrapper wrap_Func_void_TimedMetadata(Func_void_TimedMetadata value) noexcept {
    return Func_void_TimedMetadata_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const std::vector<std::string>& /* data */)>
  /**
   * Specialized version of `std::function<void(const std::vector<std::string>&)>`.
   */
  using Func_void_std__vector_std__string_ = std::function<void(const std::vector<std::string>& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<std::string>& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_std__string__Wrapper final {
  public:
    explicit Func_void_std__vector_std__string__Wrapper(std::function<void(const std::vector<std::string>& /* data */)>&& func): _function(std::make_unique<std::function<void(const std::vector<std::string>& /* data */)>>(std::move(func))) {}
    inline void call(std::vector<std::string> data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<std::string>& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_std__string_ create_Func_void_std__vector_std__string_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_std__string__Wrapper wrap_Func_void_std__vector_std__string_(Func_void_std__vector_std__string_ value) noexcept {
    return Func_void_std__vector_std__string__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::optional<std::variant<nitro::NullType, TextTrack>>& /* track */)>
  /**
   * Specialized version of `std::function<void(const std::optional<std::variant<nitro::NullType, TextTrack>>&)>`.
   */
  using Func_void_std__optional_std__variant_nitro__NullType__TextTrack__ = std::function<void(const std::optional<std::variant<nitro::NullType, TextTrack>>& /* track */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<std::variant<nitro::NullType, TextTrack>>& / * track * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_std__variant_nitro__NullType__TextTrack___Wrapper final {
  public:
    explicit Func_void_std__optional_std__variant_nitro__NullType__TextTrack___Wrapper(std::function<void(const std::optional<std::variant<nitro::NullType, TextTrack>>& /* track */)>&& func): _function(std::make_unique<std::function<void(const std::optional<std::variant<nitro::NullType, TextTrack>>& /* track */)>>(std::move(func))) {}
    inline void call(std::optional<std::variant<nitro::NullType, TextTrack>> track) const noexcept {
      _function->operator()(track);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<std::variant<nitro::NullType, TextTrack>>& /* track */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_std__variant_nitro__NullType__TextTrack__ create_Func_void_std__optional_std__variant_nitro__NullType__TextTrack__(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_std__variant_nitro__NullType__TextTrack___Wrapper wrap_Func_void_std__optional_std__variant_nitro__NullType__TextTrack__(Func_void_std__optional_std__variant_nitro__NullType__TextTrack__ value) noexcept {
    return Func_void_std__optional_std__variant_nitro__NullType__TextTrack___Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onVolumeChangeData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onVolumeChangeData&)>`.
   */
  using Func_void_onVolumeChangeData = std::function<void(const onVolumeChangeData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onVolumeChangeData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onVolumeChangeData_Wrapper final {
  public:
    explicit Func_void_onVolumeChangeData_Wrapper(std::function<void(const onVolumeChangeData& /* data */)>&& func): _function(std::make_unique<std::function<void(const onVolumeChangeData& /* data */)>>(std::move(func))) {}
    inline void call(onVolumeChangeData data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const onVolumeChangeData& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_onVolumeChangeData create_Func_void_onVolumeChangeData(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_onVolumeChangeData_Wrapper wrap_Func_void_onVolumeChangeData(Func_void_onVolumeChangeData value) noexcept {
    return Func_void_onVolumeChangeData_Wrapper(std::move(value));
  }
  
  // pragma MARK: Result<ListenerSubscription>
  using Result_ListenerSubscription_ = Result<ListenerSubscription>;
  inline Result_ListenerSubscription_ create_Result_ListenerSubscription_(const ListenerSubscription& value) noexcept {
    return Result<ListenerSubscription>::withValue(value);
  }
  inline Result_ListenerSubscription_ create_Result_ListenerSubscription_(const std::exception_ptr& error) noexcept {
    return Result<ListenerSubscription>::withError(error);
  }
  
  // pragma MARK: std::vector<NativeExternalSubtitle>
  /**
   * Specialized version of `std::vector<NativeExternalSubtitle>`.
   */
  using std__vector_NativeExternalSubtitle_ = std::vector<NativeExternalSubtitle>;
  inline std::vector<NativeExternalSubtitle> create_std__vector_NativeExternalSubtitle_(size_t size) noexcept {
    std::vector<NativeExternalSubtitle> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NativeExternalSubtitle>>
  /**
   * Specialized version of `std::optional<std::vector<NativeExternalSubtitle>>`.
   */
  using std__optional_std__vector_NativeExternalSubtitle__ = std::optional<std::vector<NativeExternalSubtitle>>;
  inline std::optional<std::vector<NativeExternalSubtitle>> create_std__optional_std__vector_NativeExternalSubtitle__(const std::vector<NativeExternalSubtitle>& value) noexcept {
    return std::optional<std::vector<NativeExternalSubtitle>>(value);
  }
  inline bool has_value_std__optional_std__vector_NativeExternalSubtitle__(const std::optional<std::vector<NativeExternalSubtitle>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NativeExternalSubtitle> get_std__optional_std__vector_NativeExternalSubtitle__(const std::optional<std::vector<NativeExternalSubtitle>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::unordered_map<std::string, std::string>
  /**
   * Specialized version of `std::unordered_map<std::string, std::string>`.
   */
  using std__unordered_map_std__string__std__string_ = std::unordered_map<std::string, std::string>;
  inline std::unordered_map<std::string, std::string> create_std__unordered_map_std__string__std__string_(size_t size) noexcept {
    std::unordered_map<std::string, std::string> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__std__string__keys(const std__unordered_map_std__string__std__string_& map) noexcept {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  inline std::string get_std__unordered_map_std__string__std__string__value(const std__unordered_map_std__string__std__string_& map, const std::string& key) noexcept {
    return map.find(key)->second;
  }
  inline void emplace_std__unordered_map_std__string__std__string_(std__unordered_map_std__string__std__string_& map, const std::string& key, const std::string& value) noexcept {
    map.emplace(key, value);
  }
  
  // pragma MARK: std::optional<std::unordered_map<std::string, std::string>>
  /**
   * Specialized version of `std::optional<std::unordered_map<std::string, std::string>>`.
   */
  using std__optional_std__unordered_map_std__string__std__string__ = std::optional<std::unordered_map<std::string, std::string>>;
  inline std::optional<std::unordered_map<std::string, std::string>> create_std__optional_std__unordered_map_std__string__std__string__(const std::unordered_map<std::string, std::string>& value) noexcept {
    return std::optional<std::unordered_map<std::string, std::string>>(value);
  }
  inline bool has_value_std__optional_std__unordered_map_std__string__std__string__(const std::optional<std::unordered_map<std::string, std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::unordered_map<std::string, std::string> get_std__optional_std__unordered_map_std__string__std__string__(const std::optional<std::unordered_map<std::string, std::string>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) noexcept {
    return std::optional<bool>(value);
  }
  inline bool has_value_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.has_value();
  }
  inline bool get_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::string>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::string>>`.
   */
  using std__shared_ptr_Promise_std__string__ = std::shared_ptr<Promise<std::string>>;
  inline std::shared_ptr<Promise<std::string>> create_std__shared_ptr_Promise_std__string__() noexcept {
    return Promise<std::string>::create();
  }
  inline PromiseHolder<std::string> wrap_std__shared_ptr_Promise_std__string__(std::shared_ptr<Promise<std::string>> promise) noexcept {
    return PromiseHolder<std::string>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::string& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::string&)>`.
   */
  using Func_void_std__string = std::function<void(const std::string& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_Wrapper final {
  public:
    explicit Func_void_std__string_Wrapper(std::function<void(const std::string& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* result */)>>(std::move(func))) {}
    inline void call(std::string result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string create_Func_void_std__string(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_Wrapper wrap_Func_void_std__string(Func_void_std__string value) noexcept {
    return Func_void_std__string_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>
  /**
   * Specialized version of `std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload&)>`.
   */
  using Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload = std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>;
  /**
   * Wrapper class for a `std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& / * payload * /)>`, this can be used from Swift.
   */
  class Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload_Wrapper final {
  public:
    explicit Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload_Wrapper(std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>&& func): _function(std::make_unique<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>>(std::move(func))) {}
    inline std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>> call(OnGetLicensePayload payload) const noexcept {
      auto __result = _function->operator()(payload);
      return __result;
    }
  private:
    std::unique_ptr<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload create_Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload_Wrapper wrap_Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload(Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload value) noexcept {
    return Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____OnGetLicensePayload_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>`.
   */
  using std__shared_ptr_Promise_std__shared_ptr_Promise_std__string____ = std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>;
  inline std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>> create_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string____() noexcept {
    return Promise<std::shared_ptr<Promise<std::string>>>::create();
  }
  inline PromiseHolder<std::shared_ptr<Promise<std::string>>> wrap_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string____(std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>> promise) noexcept {
    return PromiseHolder<std::shared_ptr<Promise<std::string>>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::shared_ptr<Promise<std::string>>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::shared_ptr<Promise<std::string>>&)>`.
   */
  using Func_void_std__shared_ptr_Promise_std__string__ = std::function<void(const std::shared_ptr<Promise<std::string>>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::shared_ptr<Promise<std::string>>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__shared_ptr_Promise_std__string___Wrapper final {
  public:
    explicit Func_void_std__shared_ptr_Promise_std__string___Wrapper(std::function<void(const std::shared_ptr<Promise<std::string>>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::shared_ptr<Promise<std::string>>& /* result */)>>(std::move(func))) {}
    inline void call(std::shared_ptr<Promise<std::string>> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::shared_ptr<Promise<std::string>>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__shared_ptr_Promise_std__string__ create_Func_void_std__shared_ptr_Promise_std__string__(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__shared_ptr_Promise_std__string___Wrapper wrap_Func_void_std__shared_ptr_Promise_std__string__(Func_void_std__shared_ptr_Promise_std__string__ value) noexcept {
    return Func_void_std__shared_ptr_Promise_std__string___Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>>
  /**
   * Specialized version of `std::optional<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& / * payload * /)>>`.
   */
  using std__optional_std__function_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____const_OnGetLicensePayload_____payload______ = std::optional<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>>;
  inline std::optional<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>> create_std__optional_std__function_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____const_OnGetLicensePayload_____payload______(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>& value) noexcept {
    return std::optional<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>>(value);
  }
  inline bool has_value_std__optional_std__function_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____const_OnGetLicensePayload_____payload______(const std::optional<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)> get_std__optional_std__function_std__shared_ptr_Promise_std__shared_ptr_Promise_std__string_____const_OnGetLicensePayload_____payload______(const std::optional<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::string>>>>(const OnGetLicensePayload& /* payload */)>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NativeDrmParams>
  /**
   * Specialized version of `std::optional<NativeDrmParams>`.
   */
  using std__optional_NativeDrmParams_ = std::optional<NativeDrmParams>;
  inline std::optional<NativeDrmParams> create_std__optional_NativeDrmParams_(const NativeDrmParams& value) noexcept {
    return std::optional<NativeDrmParams>(value);
  }
  inline bool has_value_std__optional_NativeDrmParams_(const std::optional<NativeDrmParams>& optional) noexcept {
    return optional.has_value();
  }
  inline NativeDrmParams get_std__optional_NativeDrmParams_(const std::optional<NativeDrmParams>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<LivePlaybackParams>
  /**
   * Specialized version of `std::optional<LivePlaybackParams>`.
   */
  using std__optional_LivePlaybackParams_ = std::optional<LivePlaybackParams>;
  inline std::optional<LivePlaybackParams> create_std__optional_LivePlaybackParams_(const LivePlaybackParams& value) noexcept {
    return std::optional<LivePlaybackParams>(value);
  }
  inline bool has_value_std__optional_LivePlaybackParams_(const std::optional<LivePlaybackParams>& optional) noexcept {
    return optional.has_value();
  }
  inline LivePlaybackParams get_std__optional_LivePlaybackParams_(const std::optional<LivePlaybackParams>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<Resolution>
  /**
   * Specialized version of `std::optional<Resolution>`.
   */
  using std__optional_Resolution_ = std::optional<Resolution>;
  inline std::optional<Resolution> create_std__optional_Resolution_(const Resolution& value) noexcept {
    return std::optional<Resolution>(value);
  }
  inline bool has_value_std__optional_Resolution_(const std::optional<Resolution>& optional) noexcept {
    return optional.has_value();
  }
  inline Resolution get_std__optional_Resolution_(const std::optional<Resolution>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<BufferConfig>
  /**
   * Specialized version of `std::optional<BufferConfig>`.
   */
  using std__optional_BufferConfig_ = std::optional<BufferConfig>;
  inline std::optional<BufferConfig> create_std__optional_BufferConfig_(const BufferConfig& value) noexcept {
    return std::optional<BufferConfig>(value);
  }
  inline bool has_value_std__optional_BufferConfig_(const std::optional<BufferConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline BufferConfig get_std__optional_BufferConfig_(const std::optional<BufferConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CustomVideoMetadata>
  /**
   * Specialized version of `std::optional<CustomVideoMetadata>`.
   */
  using std__optional_CustomVideoMetadata_ = std::optional<CustomVideoMetadata>;
  inline std::optional<CustomVideoMetadata> create_std__optional_CustomVideoMetadata_(const CustomVideoMetadata& value) noexcept {
    return std::optional<CustomVideoMetadata>(value);
  }
  inline bool has_value_std__optional_CustomVideoMetadata_(const std::optional<CustomVideoMetadata>& optional) noexcept {
    return optional.has_value();
  }
  inline CustomVideoMetadata get_std__optional_CustomVideoMetadata_(const std::optional<CustomVideoMetadata>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<VideoInformation>>
  /**
   * Specialized version of `std::shared_ptr<Promise<VideoInformation>>`.
   */
  using std__shared_ptr_Promise_VideoInformation__ = std::shared_ptr<Promise<VideoInformation>>;
  inline std::shared_ptr<Promise<VideoInformation>> create_std__shared_ptr_Promise_VideoInformation__() noexcept {
    return Promise<VideoInformation>::create();
  }
  inline PromiseHolder<VideoInformation> wrap_std__shared_ptr_Promise_VideoInformation__(std::shared_ptr<Promise<VideoInformation>> promise) noexcept {
    return PromiseHolder<VideoInformation>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const VideoInformation& /* result */)>
  /**
   * Specialized version of `std::function<void(const VideoInformation&)>`.
   */
  using Func_void_VideoInformation = std::function<void(const VideoInformation& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const VideoInformation& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_VideoInformation_Wrapper final {
  public:
    explicit Func_void_VideoInformation_Wrapper(std::function<void(const VideoInformation& /* result */)>&& func): _function(std::make_unique<std::function<void(const VideoInformation& /* result */)>>(std::move(func))) {}
    inline void call(VideoInformation result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const VideoInformation& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_VideoInformation create_Func_void_VideoInformation(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_VideoInformation_Wrapper wrap_Func_void_VideoInformation(Func_void_VideoInformation value) noexcept {
    return Func_void_VideoInformation_Wrapper(std::move(value));
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<VideoInformation>>>
  using Result_std__shared_ptr_Promise_VideoInformation___ = Result<std::shared_ptr<Promise<VideoInformation>>>;
  inline Result_std__shared_ptr_Promise_VideoInformation___ create_Result_std__shared_ptr_Promise_VideoInformation___(const std::shared_ptr<Promise<VideoInformation>>& value) noexcept {
    return Result<std::shared_ptr<Promise<VideoInformation>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_VideoInformation___ create_Result_std__shared_ptr_Promise_VideoInformation___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<VideoInformation>>>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<HybridVideoPlayerSourceFactorySpec>
  /**
   * Specialized version of `std::shared_ptr<HybridVideoPlayerSourceFactorySpec>`.
   */
  using std__shared_ptr_HybridVideoPlayerSourceFactorySpec_ = std::shared_ptr<HybridVideoPlayerSourceFactorySpec>;
  std::shared_ptr<HybridVideoPlayerSourceFactorySpec> create_std__shared_ptr_HybridVideoPlayerSourceFactorySpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridVideoPlayerSourceFactorySpec_(std__shared_ptr_HybridVideoPlayerSourceFactorySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridVideoPlayerSourceFactorySpec>
  using std__weak_ptr_HybridVideoPlayerSourceFactorySpec_ = std::weak_ptr<HybridVideoPlayerSourceFactorySpec>;
  inline std__weak_ptr_HybridVideoPlayerSourceFactorySpec_ weakify_std__shared_ptr_HybridVideoPlayerSourceFactorySpec_(const std::shared_ptr<HybridVideoPlayerSourceFactorySpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<HybridVideoPlayerSourceSpec>>
  using Result_std__shared_ptr_HybridVideoPlayerSourceSpec__ = Result<std::shared_ptr<HybridVideoPlayerSourceSpec>>;
  inline Result_std__shared_ptr_HybridVideoPlayerSourceSpec__ create_Result_std__shared_ptr_HybridVideoPlayerSourceSpec__(const std::shared_ptr<HybridVideoPlayerSourceSpec>& value) noexcept {
    return Result<std::shared_ptr<HybridVideoPlayerSourceSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_HybridVideoPlayerSourceSpec__ create_Result_std__shared_ptr_HybridVideoPlayerSourceSpec__(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<HybridVideoPlayerSourceSpec>>::withError(error);
  }
  
  // pragma MARK: std::optional<std::shared_ptr<HybridVideoPlayerSpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<HybridVideoPlayerSpec>>`.
   */
  using std__optional_std__shared_ptr_HybridVideoPlayerSpec__ = std::optional<std::shared_ptr<HybridVideoPlayerSpec>>;
  inline std::optional<std::shared_ptr<HybridVideoPlayerSpec>> create_std__optional_std__shared_ptr_HybridVideoPlayerSpec__(const std::shared_ptr<HybridVideoPlayerSpec>& value) noexcept {
    return std::optional<std::shared_ptr<HybridVideoPlayerSpec>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_HybridVideoPlayerSpec__(const std::optional<std::shared_ptr<HybridVideoPlayerSpec>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<HybridVideoPlayerSpec> get_std__optional_std__shared_ptr_HybridVideoPlayerSpec__(const std::optional<std::shared_ptr<HybridVideoPlayerSpec>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridVideoViewViewManagerSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridVideoViewViewManagerSpec>`.
   */
  using std__shared_ptr_HybridVideoViewViewManagerSpec_ = std::shared_ptr<HybridVideoViewViewManagerSpec>;
  std::shared_ptr<HybridVideoViewViewManagerSpec> create_std__shared_ptr_HybridVideoViewViewManagerSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridVideoViewViewManagerSpec_(std__shared_ptr_HybridVideoViewViewManagerSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridVideoViewViewManagerSpec>
  using std__weak_ptr_HybridVideoViewViewManagerSpec_ = std::weak_ptr<HybridVideoViewViewManagerSpec>;
  inline std__weak_ptr_HybridVideoViewViewManagerSpec_ weakify_std__shared_ptr_HybridVideoViewViewManagerSpec_(const std::shared_ptr<HybridVideoViewViewManagerSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<bool>
  using Result_bool_ = Result<bool>;
  inline Result_bool_ create_Result_bool_(bool value) noexcept {
    return Result<bool>::withValue(std::move(value));
  }
  inline Result_bool_ create_Result_bool_(const std::exception_ptr& error) noexcept {
    return Result<bool>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<HybridVideoViewViewManagerFactorySpec>
  /**
   * Specialized version of `std::shared_ptr<HybridVideoViewViewManagerFactorySpec>`.
   */
  using std__shared_ptr_HybridVideoViewViewManagerFactorySpec_ = std::shared_ptr<HybridVideoViewViewManagerFactorySpec>;
  std::shared_ptr<HybridVideoViewViewManagerFactorySpec> create_std__shared_ptr_HybridVideoViewViewManagerFactorySpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridVideoViewViewManagerFactorySpec_(std__shared_ptr_HybridVideoViewViewManagerFactorySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridVideoViewViewManagerFactorySpec>
  using std__weak_ptr_HybridVideoViewViewManagerFactorySpec_ = std::weak_ptr<HybridVideoViewViewManagerFactorySpec>;
  inline std__weak_ptr_HybridVideoViewViewManagerFactorySpec_ weakify_std__shared_ptr_HybridVideoViewViewManagerFactorySpec_(const std::shared_ptr<HybridVideoViewViewManagerFactorySpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<HybridVideoViewViewManagerSpec>>
  using Result_std__shared_ptr_HybridVideoViewViewManagerSpec__ = Result<std::shared_ptr<HybridVideoViewViewManagerSpec>>;
  inline Result_std__shared_ptr_HybridVideoViewViewManagerSpec__ create_Result_std__shared_ptr_HybridVideoViewViewManagerSpec__(const std::shared_ptr<HybridVideoViewViewManagerSpec>& value) noexcept {
    return Result<std::shared_ptr<HybridVideoViewViewManagerSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_HybridVideoViewViewManagerSpec__ create_Result_std__shared_ptr_HybridVideoViewViewManagerSpec__(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<HybridVideoViewViewManagerSpec>>::withError(error);
  }

} // namespace margelo::nitro::video::bridge::swift
