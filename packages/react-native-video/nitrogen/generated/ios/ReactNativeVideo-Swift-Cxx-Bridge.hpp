///
/// ReactNativeVideo-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `BandwidthData` to properly resolve imports.
namespace margelo::nitro::video { struct BandwidthData; }
// Forward declaration of `ExternalSubtitle` to properly resolve imports.
namespace margelo::nitro::video { struct ExternalSubtitle; }
// Forward declaration of `HybridVideoPlayerEventEmitterSpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerEventEmitterSpec; }
// Forward declaration of `HybridVideoPlayerFactorySpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerFactorySpec; }
// Forward declaration of `HybridVideoPlayerSourceFactorySpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerSourceFactorySpec; }
// Forward declaration of `HybridVideoPlayerSourceSpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerSourceSpec; }
// Forward declaration of `HybridVideoPlayerSpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoPlayerSpec; }
// Forward declaration of `HybridVideoViewViewManagerFactorySpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoViewViewManagerFactorySpec; }
// Forward declaration of `HybridVideoViewViewManagerSpec` to properly resolve imports.
namespace margelo::nitro::video { class HybridVideoViewViewManagerSpec; }
// Forward declaration of `SourceType` to properly resolve imports.
namespace margelo::nitro::video { enum class SourceType; }
// Forward declaration of `TimedMetadataObject` to properly resolve imports.
namespace margelo::nitro::video { struct TimedMetadataObject; }
// Forward declaration of `TimedMetadata` to properly resolve imports.
namespace margelo::nitro::video { struct TimedMetadata; }
// Forward declaration of `VideoInformation` to properly resolve imports.
namespace margelo::nitro::video { struct VideoInformation; }
// Forward declaration of `VideoOrientation` to properly resolve imports.
namespace margelo::nitro::video { enum class VideoOrientation; }
// Forward declaration of `VideoPlayerStatus` to properly resolve imports.
namespace margelo::nitro::video { enum class VideoPlayerStatus; }
// Forward declaration of `onLoadData` to properly resolve imports.
namespace margelo::nitro::video { struct onLoadData; }
// Forward declaration of `onLoadStartData` to properly resolve imports.
namespace margelo::nitro::video { struct onLoadStartData; }
// Forward declaration of `onPlaybackStateChangeData` to properly resolve imports.
namespace margelo::nitro::video { struct onPlaybackStateChangeData; }
// Forward declaration of `onProgressData` to properly resolve imports.
namespace margelo::nitro::video { struct onProgressData; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridVideoPlayerEventEmitterSpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerEventEmitterSpec_cxx; }
// Forward declaration of `HybridVideoPlayerFactorySpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerFactorySpec_cxx; }
// Forward declaration of `HybridVideoPlayerSourceFactorySpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerSourceFactorySpec_cxx; }
// Forward declaration of `HybridVideoPlayerSourceSpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerSourceSpec_cxx; }
// Forward declaration of `HybridVideoPlayerSpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoPlayerSpec_cxx; }
// Forward declaration of `HybridVideoViewViewManagerFactorySpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoViewViewManagerFactorySpec_cxx; }
// Forward declaration of `HybridVideoViewViewManagerSpec_cxx` to properly resolve imports.
namespace ReactNativeVideo { class HybridVideoViewViewManagerSpec_cxx; }

// Include C++ defined types
#include "BandwidthData.hpp"
#include "ExternalSubtitle.hpp"
#include "HybridVideoPlayerEventEmitterSpec.hpp"
#include "HybridVideoPlayerFactorySpec.hpp"
#include "HybridVideoPlayerSourceFactorySpec.hpp"
#include "HybridVideoPlayerSourceSpec.hpp"
#include "HybridVideoPlayerSpec.hpp"
#include "HybridVideoViewViewManagerFactorySpec.hpp"
#include "HybridVideoViewViewManagerSpec.hpp"
#include "SourceType.hpp"
#include "TimedMetadata.hpp"
#include "TimedMetadataObject.hpp"
#include "VideoInformation.hpp"
#include "VideoOrientation.hpp"
#include "VideoPlayerStatus.hpp"
#include "onLoadData.hpp"
#include "onLoadStartData.hpp"
#include "onPlaybackStateChangeData.hpp"
#include "onProgressData.hpp"
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::video::bridge::swift {

  // pragma MARK: std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>
  /**
   * Specialized version of `std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>`.
   */
  using std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec_ = std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>;
  std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec> create_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec_(void* _Nonnull swiftUnsafePointer);
  void* _Nonnull get_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec_(std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>
  using std__weak_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec_ = std::weak_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>;
  inline std__weak_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec_ weakify_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec_(const std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>& strong) { return strong; }
  
  // pragma MARK: std::shared_ptr<margelo::nitro::video::HybridVideoPlayerEventEmitterSpec>
  /**
   * Specialized version of `std::shared_ptr<margelo::nitro::video::HybridVideoPlayerEventEmitterSpec>`.
   */
  using std__shared_ptr_margelo__nitro__video__HybridVideoPlayerEventEmitterSpec_ = std::shared_ptr<margelo::nitro::video::HybridVideoPlayerEventEmitterSpec>;
  std::shared_ptr<margelo::nitro::video::HybridVideoPlayerEventEmitterSpec> create_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerEventEmitterSpec_(void* _Nonnull swiftUnsafePointer);
  void* _Nonnull get_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerEventEmitterSpec_(std__shared_ptr_margelo__nitro__video__HybridVideoPlayerEventEmitterSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<margelo::nitro::video::HybridVideoPlayerEventEmitterSpec>
  using std__weak_ptr_margelo__nitro__video__HybridVideoPlayerEventEmitterSpec_ = std::weak_ptr<margelo::nitro::video::HybridVideoPlayerEventEmitterSpec>;
  inline std__weak_ptr_margelo__nitro__video__HybridVideoPlayerEventEmitterSpec_ weakify_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerEventEmitterSpec_(const std::shared_ptr<margelo::nitro::video::HybridVideoPlayerEventEmitterSpec>& strong) { return strong; }
  
  // pragma MARK: std::shared_ptr<Promise<void>>
  /**
   * Specialized version of `std::shared_ptr<Promise<void>>`.
   */
  using std__shared_ptr_Promise_void__ = std::shared_ptr<Promise<void>>;
  inline std::shared_ptr<Promise<void>> create_std__shared_ptr_Promise_void__() {
    return Promise<void>::create();
  }
  inline PromiseHolder<void> wrap_std__shared_ptr_Promise_void__(std::shared_ptr<Promise<void>> promise) {
    return PromiseHolder<void>(std::move(promise));
  }
  
  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_shared<std::function<void()>>(std::move(func))) {}
    inline void call() const {
      _function->operator()();
    }
  private:
    std::shared_ptr<std::function<void()>> _function;
  };
  Func_void create_Func_void(void* _Nonnull swiftClosureWrapper);
  inline Func_void_Wrapper wrap_Func_void(Func_void value) {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_shared<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const {
      _function->operator()(error);
    }
  private:
    std::shared_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  };
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* _Nonnull swiftClosureWrapper);
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>
  /**
   * Specialized version of `std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>`.
   */
  using std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec_ = std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>;
  std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec> create_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec_(void* _Nonnull swiftUnsafePointer);
  void* _Nonnull get_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec_(std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<margelo::nitro::video::HybridVideoPlayerSpec>
  using std__weak_ptr_margelo__nitro__video__HybridVideoPlayerSpec_ = std::weak_ptr<margelo::nitro::video::HybridVideoPlayerSpec>;
  inline std__weak_ptr_margelo__nitro__video__HybridVideoPlayerSpec_ weakify_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec_(const std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>& strong) { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<void>>>
  using Result_std__shared_ptr_Promise_void___ = Result<std::shared_ptr<Promise<void>>>;
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::shared_ptr<Promise<void>>& value) {
    return Result<std::shared_ptr<Promise<void>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::exception_ptr& error) {
    return Result<std::shared_ptr<Promise<void>>>::withError(error);
  }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) {
    return Result<void>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<margelo::nitro::video::HybridVideoPlayerFactorySpec>
  /**
   * Specialized version of `std::shared_ptr<margelo::nitro::video::HybridVideoPlayerFactorySpec>`.
   */
  using std__shared_ptr_margelo__nitro__video__HybridVideoPlayerFactorySpec_ = std::shared_ptr<margelo::nitro::video::HybridVideoPlayerFactorySpec>;
  std::shared_ptr<margelo::nitro::video::HybridVideoPlayerFactorySpec> create_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerFactorySpec_(void* _Nonnull swiftUnsafePointer);
  void* _Nonnull get_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerFactorySpec_(std__shared_ptr_margelo__nitro__video__HybridVideoPlayerFactorySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<margelo::nitro::video::HybridVideoPlayerFactorySpec>
  using std__weak_ptr_margelo__nitro__video__HybridVideoPlayerFactorySpec_ = std::weak_ptr<margelo::nitro::video::HybridVideoPlayerFactorySpec>;
  inline std__weak_ptr_margelo__nitro__video__HybridVideoPlayerFactorySpec_ weakify_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerFactorySpec_(const std::shared_ptr<margelo::nitro::video::HybridVideoPlayerFactorySpec>& strong) { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>>
  using Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec__ = Result<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>>;
  inline Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec__ create_Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec__(const std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>& value) {
    return Result<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec__ create_Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec__(const std::exception_ptr& error) {
    return Result<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>>::withError(error);
  }
  
  // pragma MARK: std::function<void(bool /* hasAudioFocus */)>
  /**
   * Specialized version of `std::function<void(bool)>`.
   */
  using Func_void_bool = std::function<void(bool /* hasAudioFocus */)>;
  /**
   * Wrapper class for a `std::function<void(bool / * hasAudioFocus * /)>`, this can be used from Swift.
   */
  class Func_void_bool_Wrapper final {
  public:
    explicit Func_void_bool_Wrapper(std::function<void(bool /* hasAudioFocus */)>&& func): _function(std::make_shared<std::function<void(bool /* hasAudioFocus */)>>(std::move(func))) {}
    inline void call(bool hasAudioFocus) const {
      _function->operator()(hasAudioFocus);
    }
  private:
    std::shared_ptr<std::function<void(bool /* hasAudioFocus */)>> _function;
  };
  Func_void_bool create_Func_void_bool(void* _Nonnull swiftClosureWrapper);
  inline Func_void_bool_Wrapper wrap_Func_void_bool(Func_void_bool value) {
    return Func_void_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) {
    return std::optional<double>(value);
  }
  
  // pragma MARK: std::function<void(const BandwidthData& /* data */)>
  /**
   * Specialized version of `std::function<void(const BandwidthData&)>`.
   */
  using Func_void_BandwidthData = std::function<void(const BandwidthData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const BandwidthData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_BandwidthData_Wrapper final {
  public:
    explicit Func_void_BandwidthData_Wrapper(std::function<void(const BandwidthData& /* data */)>&& func): _function(std::make_shared<std::function<void(const BandwidthData& /* data */)>>(std::move(func))) {}
    inline void call(BandwidthData data) const {
      _function->operator()(data);
    }
  private:
    std::shared_ptr<std::function<void(const BandwidthData& /* data */)>> _function;
  };
  Func_void_BandwidthData create_Func_void_BandwidthData(void* _Nonnull swiftClosureWrapper);
  inline Func_void_BandwidthData_Wrapper wrap_Func_void_BandwidthData(Func_void_BandwidthData value) {
    return Func_void_BandwidthData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onLoadData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onLoadData&)>`.
   */
  using Func_void_onLoadData = std::function<void(const onLoadData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onLoadData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onLoadData_Wrapper final {
  public:
    explicit Func_void_onLoadData_Wrapper(std::function<void(const onLoadData& /* data */)>&& func): _function(std::make_shared<std::function<void(const onLoadData& /* data */)>>(std::move(func))) {}
    inline void call(onLoadData data) const {
      _function->operator()(data);
    }
  private:
    std::shared_ptr<std::function<void(const onLoadData& /* data */)>> _function;
  };
  Func_void_onLoadData create_Func_void_onLoadData(void* _Nonnull swiftClosureWrapper);
  inline Func_void_onLoadData_Wrapper wrap_Func_void_onLoadData(Func_void_onLoadData value) {
    return Func_void_onLoadData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onLoadStartData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onLoadStartData&)>`.
   */
  using Func_void_onLoadStartData = std::function<void(const onLoadStartData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onLoadStartData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onLoadStartData_Wrapper final {
  public:
    explicit Func_void_onLoadStartData_Wrapper(std::function<void(const onLoadStartData& /* data */)>&& func): _function(std::make_shared<std::function<void(const onLoadStartData& /* data */)>>(std::move(func))) {}
    inline void call(onLoadStartData data) const {
      _function->operator()(data);
    }
  private:
    std::shared_ptr<std::function<void(const onLoadStartData& /* data */)>> _function;
  };
  Func_void_onLoadStartData create_Func_void_onLoadStartData(void* _Nonnull swiftClosureWrapper);
  inline Func_void_onLoadStartData_Wrapper wrap_Func_void_onLoadStartData(Func_void_onLoadStartData value) {
    return Func_void_onLoadStartData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onPlaybackStateChangeData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onPlaybackStateChangeData&)>`.
   */
  using Func_void_onPlaybackStateChangeData = std::function<void(const onPlaybackStateChangeData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onPlaybackStateChangeData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onPlaybackStateChangeData_Wrapper final {
  public:
    explicit Func_void_onPlaybackStateChangeData_Wrapper(std::function<void(const onPlaybackStateChangeData& /* data */)>&& func): _function(std::make_shared<std::function<void(const onPlaybackStateChangeData& /* data */)>>(std::move(func))) {}
    inline void call(onPlaybackStateChangeData data) const {
      _function->operator()(data);
    }
  private:
    std::shared_ptr<std::function<void(const onPlaybackStateChangeData& /* data */)>> _function;
  };
  Func_void_onPlaybackStateChangeData create_Func_void_onPlaybackStateChangeData(void* _Nonnull swiftClosureWrapper);
  inline Func_void_onPlaybackStateChangeData_Wrapper wrap_Func_void_onPlaybackStateChangeData(Func_void_onPlaybackStateChangeData value) {
    return Func_void_onPlaybackStateChangeData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(double /* rate */)>
  /**
   * Specialized version of `std::function<void(double)>`.
   */
  using Func_void_double = std::function<void(double /* rate */)>;
  /**
   * Wrapper class for a `std::function<void(double / * rate * /)>`, this can be used from Swift.
   */
  class Func_void_double_Wrapper final {
  public:
    explicit Func_void_double_Wrapper(std::function<void(double /* rate */)>&& func): _function(std::make_shared<std::function<void(double /* rate */)>>(std::move(func))) {}
    inline void call(double rate) const {
      _function->operator()(rate);
    }
  private:
    std::shared_ptr<std::function<void(double /* rate */)>> _function;
  };
  Func_void_double create_Func_void_double(void* _Nonnull swiftClosureWrapper);
  inline Func_void_double_Wrapper wrap_Func_void_double(Func_void_double value) {
    return Func_void_double_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const onProgressData& /* data */)>
  /**
   * Specialized version of `std::function<void(const onProgressData&)>`.
   */
  using Func_void_onProgressData = std::function<void(const onProgressData& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const onProgressData& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_onProgressData_Wrapper final {
  public:
    explicit Func_void_onProgressData_Wrapper(std::function<void(const onProgressData& /* data */)>&& func): _function(std::make_shared<std::function<void(const onProgressData& /* data */)>>(std::move(func))) {}
    inline void call(onProgressData data) const {
      _function->operator()(data);
    }
  private:
    std::shared_ptr<std::function<void(const onProgressData& /* data */)>> _function;
  };
  Func_void_onProgressData create_Func_void_onProgressData(void* _Nonnull swiftClosureWrapper);
  inline Func_void_onProgressData_Wrapper wrap_Func_void_onProgressData(Func_void_onProgressData value) {
    return Func_void_onProgressData_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<TimedMetadataObject>
  /**
   * Specialized version of `std::vector<TimedMetadataObject>`.
   */
  using std__vector_TimedMetadataObject_ = std::vector<TimedMetadataObject>;
  inline std::vector<TimedMetadataObject> create_std__vector_TimedMetadataObject_(size_t size) {
    std::vector<TimedMetadataObject> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const TimedMetadata& /* metadata */)>
  /**
   * Specialized version of `std::function<void(const TimedMetadata&)>`.
   */
  using Func_void_TimedMetadata = std::function<void(const TimedMetadata& /* metadata */)>;
  /**
   * Wrapper class for a `std::function<void(const TimedMetadata& / * metadata * /)>`, this can be used from Swift.
   */
  class Func_void_TimedMetadata_Wrapper final {
  public:
    explicit Func_void_TimedMetadata_Wrapper(std::function<void(const TimedMetadata& /* metadata */)>&& func): _function(std::make_shared<std::function<void(const TimedMetadata& /* metadata */)>>(std::move(func))) {}
    inline void call(TimedMetadata metadata) const {
      _function->operator()(metadata);
    }
  private:
    std::shared_ptr<std::function<void(const TimedMetadata& /* metadata */)>> _function;
  };
  Func_void_TimedMetadata create_Func_void_TimedMetadata(void* _Nonnull swiftClosureWrapper);
  inline Func_void_TimedMetadata_Wrapper wrap_Func_void_TimedMetadata(Func_void_TimedMetadata value) {
    return Func_void_TimedMetadata_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const std::vector<std::string>& /* texts */)>
  /**
   * Specialized version of `std::function<void(const std::vector<std::string>&)>`.
   */
  using Func_void_std__vector_std__string_ = std::function<void(const std::vector<std::string>& /* texts */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<std::string>& / * texts * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_std__string__Wrapper final {
  public:
    explicit Func_void_std__vector_std__string__Wrapper(std::function<void(const std::vector<std::string>& /* texts */)>&& func): _function(std::make_shared<std::function<void(const std::vector<std::string>& /* texts */)>>(std::move(func))) {}
    inline void call(std::vector<std::string> texts) const {
      _function->operator()(texts);
    }
  private:
    std::shared_ptr<std::function<void(const std::vector<std::string>& /* texts */)>> _function;
  };
  Func_void_std__vector_std__string_ create_Func_void_std__vector_std__string_(void* _Nonnull swiftClosureWrapper);
  inline Func_void_std__vector_std__string__Wrapper wrap_Func_void_std__vector_std__string_(Func_void_std__vector_std__string_ value) {
    return Func_void_std__vector_std__string__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(VideoPlayerStatus /* status */)>
  /**
   * Specialized version of `std::function<void(VideoPlayerStatus)>`.
   */
  using Func_void_VideoPlayerStatus = std::function<void(VideoPlayerStatus /* status */)>;
  /**
   * Wrapper class for a `std::function<void(VideoPlayerStatus / * status * /)>`, this can be used from Swift.
   */
  class Func_void_VideoPlayerStatus_Wrapper final {
  public:
    explicit Func_void_VideoPlayerStatus_Wrapper(std::function<void(VideoPlayerStatus /* status */)>&& func): _function(std::make_shared<std::function<void(VideoPlayerStatus /* status */)>>(std::move(func))) {}
    inline void call(int status) const {
      _function->operator()(static_cast<VideoPlayerStatus>(status));
    }
  private:
    std::shared_ptr<std::function<void(VideoPlayerStatus /* status */)>> _function;
  };
  Func_void_VideoPlayerStatus create_Func_void_VideoPlayerStatus(void* _Nonnull swiftClosureWrapper);
  inline Func_void_VideoPlayerStatus_Wrapper wrap_Func_void_VideoPlayerStatus(Func_void_VideoPlayerStatus value) {
    return Func_void_VideoPlayerStatus_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::unordered_map<std::string, std::string>
  /**
   * Specialized version of `std::unordered_map<std::string, std::string>`.
   */
  using std__unordered_map_std__string__std__string_ = std::unordered_map<std::string, std::string>;
  inline std::unordered_map<std::string, std::string> create_std__unordered_map_std__string__std__string_(size_t size) {
    std::unordered_map<std::string, std::string> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__std__string__keys(const std__unordered_map_std__string__std__string_& map) {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  inline void emplace_std__unordered_map_std__string__std__string_(std__unordered_map_std__string__std__string_& map, const std::string& key, const std::string& value) {
    map.emplace(key, value);
  }
  
  // pragma MARK: std::optional<std::unordered_map<std::string, std::string>>
  /**
   * Specialized version of `std::optional<std::unordered_map<std::string, std::string>>`.
   */
  using std__optional_std__unordered_map_std__string__std__string__ = std::optional<std::unordered_map<std::string, std::string>>;
  inline std::optional<std::unordered_map<std::string, std::string>> create_std__optional_std__unordered_map_std__string__std__string__(const std::unordered_map<std::string, std::string>& value) {
    return std::optional<std::unordered_map<std::string, std::string>>(value);
  }
  
  // pragma MARK: std::vector<ExternalSubtitle>
  /**
   * Specialized version of `std::vector<ExternalSubtitle>`.
   */
  using std__vector_ExternalSubtitle_ = std::vector<ExternalSubtitle>;
  inline std::vector<ExternalSubtitle> create_std__vector_ExternalSubtitle_(size_t size) {
    std::vector<ExternalSubtitle> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<ExternalSubtitle>>
  /**
   * Specialized version of `std::optional<std::vector<ExternalSubtitle>>`.
   */
  using std__optional_std__vector_ExternalSubtitle__ = std::optional<std::vector<ExternalSubtitle>>;
  inline std::optional<std::vector<ExternalSubtitle>> create_std__optional_std__vector_ExternalSubtitle__(const std::vector<ExternalSubtitle>& value) {
    return std::optional<std::vector<ExternalSubtitle>>(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<VideoInformation>>
  /**
   * Specialized version of `std::shared_ptr<Promise<VideoInformation>>`.
   */
  using std__shared_ptr_Promise_VideoInformation__ = std::shared_ptr<Promise<VideoInformation>>;
  inline std::shared_ptr<Promise<VideoInformation>> create_std__shared_ptr_Promise_VideoInformation__() {
    return Promise<VideoInformation>::create();
  }
  inline PromiseHolder<VideoInformation> wrap_std__shared_ptr_Promise_VideoInformation__(std::shared_ptr<Promise<VideoInformation>> promise) {
    return PromiseHolder<VideoInformation>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const VideoInformation& /* result */)>
  /**
   * Specialized version of `std::function<void(const VideoInformation&)>`.
   */
  using Func_void_VideoInformation = std::function<void(const VideoInformation& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const VideoInformation& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_VideoInformation_Wrapper final {
  public:
    explicit Func_void_VideoInformation_Wrapper(std::function<void(const VideoInformation& /* result */)>&& func): _function(std::make_shared<std::function<void(const VideoInformation& /* result */)>>(std::move(func))) {}
    inline void call(VideoInformation result) const {
      _function->operator()(result);
    }
  private:
    std::shared_ptr<std::function<void(const VideoInformation& /* result */)>> _function;
  };
  Func_void_VideoInformation create_Func_void_VideoInformation(void* _Nonnull swiftClosureWrapper);
  inline Func_void_VideoInformation_Wrapper wrap_Func_void_VideoInformation(Func_void_VideoInformation value) {
    return Func_void_VideoInformation_Wrapper(std::move(value));
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<VideoInformation>>>
  using Result_std__shared_ptr_Promise_VideoInformation___ = Result<std::shared_ptr<Promise<VideoInformation>>>;
  inline Result_std__shared_ptr_Promise_VideoInformation___ create_Result_std__shared_ptr_Promise_VideoInformation___(const std::shared_ptr<Promise<VideoInformation>>& value) {
    return Result<std::shared_ptr<Promise<VideoInformation>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_VideoInformation___ create_Result_std__shared_ptr_Promise_VideoInformation___(const std::exception_ptr& error) {
    return Result<std::shared_ptr<Promise<VideoInformation>>>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceFactorySpec>
  /**
   * Specialized version of `std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceFactorySpec>`.
   */
  using std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceFactorySpec_ = std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceFactorySpec>;
  std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceFactorySpec> create_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceFactorySpec_(void* _Nonnull swiftUnsafePointer);
  void* _Nonnull get_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceFactorySpec_(std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceFactorySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<margelo::nitro::video::HybridVideoPlayerSourceFactorySpec>
  using std__weak_ptr_margelo__nitro__video__HybridVideoPlayerSourceFactorySpec_ = std::weak_ptr<margelo::nitro::video::HybridVideoPlayerSourceFactorySpec>;
  inline std__weak_ptr_margelo__nitro__video__HybridVideoPlayerSourceFactorySpec_ weakify_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceFactorySpec_(const std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceFactorySpec>& strong) { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>>
  using Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec__ = Result<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>>;
  inline Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec__ create_Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec__(const std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>& value) {
    return Result<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec__ create_Result_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSourceSpec__(const std::exception_ptr& error) {
    return Result<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSourceSpec>>::withError(error);
  }
  
  // pragma MARK: std::optional<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>>`.
   */
  using std__optional_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec__ = std::optional<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>>;
  inline std::optional<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>> create_std__optional_std__shared_ptr_margelo__nitro__video__HybridVideoPlayerSpec__(const std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>& value) {
    return std::optional<std::shared_ptr<margelo::nitro::video::HybridVideoPlayerSpec>>(value);
  }
  
  // pragma MARK: std::optional<std::function<void(bool /* isInPictureInPicture */)>>
  /**
   * Specialized version of `std::optional<std::function<void(bool / * isInPictureInPicture * /)>>`.
   */
  using std__optional_std__function_void_bool____isInPictureInPicture______ = std::optional<std::function<void(bool /* isInPictureInPicture */)>>;
  inline std::optional<std::function<void(bool /* isInPictureInPicture */)>> create_std__optional_std__function_void_bool____isInPictureInPicture______(const std::function<void(bool /* isInPictureInPicture */)>& value) {
    return std::optional<std::function<void(bool /* isInPictureInPicture */)>>(value);
  }
  
  // pragma MARK: std::optional<std::function<void(bool /* fullscreen */)>>
  /**
   * Specialized version of `std::optional<std::function<void(bool / * fullscreen * /)>>`.
   */
  using std__optional_std__function_void_bool____fullscreen______ = std::optional<std::function<void(bool /* fullscreen */)>>;
  inline std::optional<std::function<void(bool /* fullscreen */)>> create_std__optional_std__function_void_bool____fullscreen______(const std::function<void(bool /* fullscreen */)>& value) {
    return std::optional<std::function<void(bool /* fullscreen */)>>(value);
  }
  
  // pragma MARK: std::optional<std::function<void()>>
  /**
   * Specialized version of `std::optional<std::function<void()>>`.
   */
  using std__optional_std__function_void____ = std::optional<std::function<void()>>;
  inline std::optional<std::function<void()>> create_std__optional_std__function_void____(const std::function<void()>& value) {
    return std::optional<std::function<void()>>(value);
  }
  
  // pragma MARK: std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>
  /**
   * Specialized version of `std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>`.
   */
  using std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec_ = std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>;
  std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec> create_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec_(void* _Nonnull swiftUnsafePointer);
  void* _Nonnull get_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec_(std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>
  using std__weak_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec_ = std::weak_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>;
  inline std__weak_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec_ weakify_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec_(const std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>& strong) { return strong; }
  
  // pragma MARK: Result<bool>
  using Result_bool_ = Result<bool>;
  inline Result_bool_ create_Result_bool_(bool value) {
    return Result<bool>::withValue(std::move(value));
  }
  inline Result_bool_ create_Result_bool_(const std::exception_ptr& error) {
    return Result<bool>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerFactorySpec>
  /**
   * Specialized version of `std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerFactorySpec>`.
   */
  using std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerFactorySpec_ = std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerFactorySpec>;
  std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerFactorySpec> create_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerFactorySpec_(void* _Nonnull swiftUnsafePointer);
  void* _Nonnull get_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerFactorySpec_(std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerFactorySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<margelo::nitro::video::HybridVideoViewViewManagerFactorySpec>
  using std__weak_ptr_margelo__nitro__video__HybridVideoViewViewManagerFactorySpec_ = std::weak_ptr<margelo::nitro::video::HybridVideoViewViewManagerFactorySpec>;
  inline std__weak_ptr_margelo__nitro__video__HybridVideoViewViewManagerFactorySpec_ weakify_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerFactorySpec_(const std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerFactorySpec>& strong) { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>>
  using Result_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec__ = Result<std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>>;
  inline Result_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec__ create_Result_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec__(const std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>& value) {
    return Result<std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec__ create_Result_std__shared_ptr_margelo__nitro__video__HybridVideoViewViewManagerSpec__(const std::exception_ptr& error) {
    return Result<std::shared_ptr<margelo::nitro::video::HybridVideoViewViewManagerSpec>>::withError(error);
  }

} // namespace margelo::nitro::video::bridge::swift
