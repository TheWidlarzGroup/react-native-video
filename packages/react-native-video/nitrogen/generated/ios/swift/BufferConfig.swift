///
/// BufferConfig.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `BufferConfig`, backed by a C++ struct.
 */
public typealias BufferConfig = margelo.nitro.video.BufferConfig

public extension BufferConfig {
  private typealias bridge = margelo.nitro.video.bridge.swift

  /**
   * Create a new instance of `BufferConfig`.
   */
  init(livePlayback: LivePlaybackParams?, minBufferMs: Double?, maxBufferMs: Double?, bufferForPlaybackMs: Double?, bufferForPlaybackAfterRebufferMs: Double?, backBufferDurationMs: Double?, preferredForwardBufferDurationMs: Double?, preferredPeakBitRate: Double?, preferredMaximumResolution: Resolution?, preferredPeakBitRateForExpensiveNetworks: Double?, preferredMaximumResolutionForExpensiveNetworks: Resolution?) {
    self.init({ () -> bridge.std__optional_LivePlaybackParams_ in
      if let __unwrappedValue = livePlayback {
        return bridge.create_std__optional_LivePlaybackParams_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = minBufferMs {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = maxBufferMs {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = bufferForPlaybackMs {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = bufferForPlaybackAfterRebufferMs {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = backBufferDurationMs {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = preferredForwardBufferDurationMs {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = preferredPeakBitRate {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_Resolution_ in
      if let __unwrappedValue = preferredMaximumResolution {
        return bridge.create_std__optional_Resolution_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = preferredPeakBitRateForExpensiveNetworks {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_Resolution_ in
      if let __unwrappedValue = preferredMaximumResolutionForExpensiveNetworks {
        return bridge.create_std__optional_Resolution_(__unwrappedValue)
      } else {
        return .init()
      }
    }())
  }

  var livePlayback: LivePlaybackParams? {
    @inline(__always)
    get {
      return self.__livePlayback.value
    }
    @inline(__always)
    set {
      self.__livePlayback = { () -> bridge.std__optional_LivePlaybackParams_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_LivePlaybackParams_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var minBufferMs: Double? {
    @inline(__always)
    get {
      return self.__minBufferMs.value
    }
    @inline(__always)
    set {
      self.__minBufferMs = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var maxBufferMs: Double? {
    @inline(__always)
    get {
      return self.__maxBufferMs.value
    }
    @inline(__always)
    set {
      self.__maxBufferMs = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var bufferForPlaybackMs: Double? {
    @inline(__always)
    get {
      return self.__bufferForPlaybackMs.value
    }
    @inline(__always)
    set {
      self.__bufferForPlaybackMs = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var bufferForPlaybackAfterRebufferMs: Double? {
    @inline(__always)
    get {
      return self.__bufferForPlaybackAfterRebufferMs.value
    }
    @inline(__always)
    set {
      self.__bufferForPlaybackAfterRebufferMs = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var backBufferDurationMs: Double? {
    @inline(__always)
    get {
      return self.__backBufferDurationMs.value
    }
    @inline(__always)
    set {
      self.__backBufferDurationMs = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var preferredForwardBufferDurationMs: Double? {
    @inline(__always)
    get {
      return self.__preferredForwardBufferDurationMs.value
    }
    @inline(__always)
    set {
      self.__preferredForwardBufferDurationMs = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var preferredPeakBitRate: Double? {
    @inline(__always)
    get {
      return self.__preferredPeakBitRate.value
    }
    @inline(__always)
    set {
      self.__preferredPeakBitRate = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var preferredMaximumResolution: Resolution? {
    @inline(__always)
    get {
      return self.__preferredMaximumResolution.value
    }
    @inline(__always)
    set {
      self.__preferredMaximumResolution = { () -> bridge.std__optional_Resolution_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_Resolution_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var preferredPeakBitRateForExpensiveNetworks: Double? {
    @inline(__always)
    get {
      return self.__preferredPeakBitRateForExpensiveNetworks.value
    }
    @inline(__always)
    set {
      self.__preferredPeakBitRateForExpensiveNetworks = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var preferredMaximumResolutionForExpensiveNetworks: Resolution? {
    @inline(__always)
    get {
      return self.__preferredMaximumResolutionForExpensiveNetworks.value
    }
    @inline(__always)
    set {
      self.__preferredMaximumResolutionForExpensiveNetworks = { () -> bridge.std__optional_Resolution_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_Resolution_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
}
